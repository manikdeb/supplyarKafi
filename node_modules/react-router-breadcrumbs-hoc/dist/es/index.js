import React, { createElement } from 'react';
import { withRouter, matchPath } from 'react-router';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

/* eslint-disable-next-line */

var DEFAULT_MATCH_OPTIONS = {
  exact: true
};
var NO_BREADCRUMB = 'NO_BREADCRUMB';
/**
 * This method was "borrowed" from https://stackoverflow.com/a/28339742
 * we used to use the humanize-string package, but it added a lot of bundle
 * size and issues with compilation. This 4-liner seems to cover most cases.
 */

var humanize = function humanize(str) {
  return str.replace(/^[\s_]+|[\s_]+$/g, '').replace(/[_\s]+/g, ' ').replace(/^[a-z]/, function (m) {
    return m.toUpperCase();
  });
};
/**
 * Renders and returns the breadcrumb complete
 * with `match`, `location`, and `key` props.
 */


var render = function render(_ref) {
  var Breadcrumb = _ref.breadcrumb,
      match = _ref.match,
      location = _ref.location,
      rest = _objectWithoutProperties(_ref, ["breadcrumb", "match", "location"]);

  var componentProps = _objectSpread2({
    match: match,
    location: location,
    key: match.url
  }, rest);

  return _objectSpread2({}, componentProps, {
    breadcrumb: typeof Breadcrumb === 'string' ? createElement('span', {
      key: componentProps.key
    }, Breadcrumb) : React.createElement(Breadcrumb, componentProps)
  });
};
/**
 * Small helper method to get a default breadcrumb if the user hasn't provided one.
*/


var getDefaultBreadcrumb = function getDefaultBreadcrumb(_ref2) {
  var currentSection = _ref2.currentSection,
      location = _ref2.location,
      pathSection = _ref2.pathSection;
  var match = matchPath(pathSection, _objectSpread2({}, DEFAULT_MATCH_OPTIONS, {
    path: pathSection
  }))
  /* istanbul ignore next: this is hard to mock in jest :( */
  || {
    url: 'not-found'
  };
  return render({
    breadcrumb: humanize(currentSection),
    match: match,
    location: location
  });
};
/**
 * Loops through the route array (if provided) and returns either a
 * user-provided breadcrumb OR a sensible default (if enabled)
*/


var getBreadcrumbMatch = function getBreadcrumbMatch(_ref3) {
  var currentSection = _ref3.currentSection,
      disableDefaults = _ref3.disableDefaults,
      excludePaths = _ref3.excludePaths,
      location = _ref3.location,
      pathSection = _ref3.pathSection,
      routes = _ref3.routes;
  var breadcrumb; // Check the optional `excludePaths` option in `options` to see if the
  // current path should not include a breadcrumb.

  var getIsPathExcluded = function getIsPathExcluded(path) {
    return matchPath(pathSection, {
      path: path,
      exact: true,
      strict: false
    });
  };

  if (excludePaths && excludePaths.some(getIsPathExcluded)) {
    return NO_BREADCRUMB;
  } // Loop through the route array and see if the user has provided a custom breadcrumb.


  routes.some(function (_ref4) {
    var userProvidedBreadcrumb = _ref4.breadcrumb,
        matchOptions = _ref4.matchOptions,
        path = _ref4.path,
        rest = _objectWithoutProperties(_ref4, ["breadcrumb", "matchOptions", "path"]);

    if (!path) {
      throw new Error('withBreadcrumbs: `path` must be provided in every route object');
    }

    var match = matchPath(pathSection, _objectSpread2({}, matchOptions || DEFAULT_MATCH_OPTIONS, {
      path: path
    })); // If user passed breadcrumb: null OR custom match options to suppress a breadcrumb
    // we need to know NOT to add it to the matches array
    // see: `if (breadcrumb !== NO_BREADCRUMB)` below.

    if (match && userProvidedBreadcrumb === null || !match && matchOptions) {
      breadcrumb = NO_BREADCRUMB;
      return true;
    }

    if (match) {
      // This covers the case where a user may be extending their react-router route
      // config with breadcrumbs, but also does not want default breadcrumbs to be
      // automatically generated (opt-in).
      if (!userProvidedBreadcrumb && disableDefaults) {
        breadcrumb = NO_BREADCRUMB;
        return true;
      }

      breadcrumb = render(_objectSpread2({
        // Although we have a match, the user may be passing their react-router config object
        // which we support. The route config object may not have a `breadcrumb` param specified.
        // If this is the case, we should provide a default via `humanize`.
        breadcrumb: userProvidedBreadcrumb || humanize(currentSection),
        match: match,
        location: location
      }, rest));
      return true;
    }

    return false;
  }); // User provided a breadcrumb prop, or we generated one above.

  if (breadcrumb) {
    return breadcrumb;
  } // If there was no breadcrumb provided and user has disableDefaults turned on.


  if (disableDefaults) {
    return NO_BREADCRUMB;
  } // If the above conditionals don't fire, generate a default breadcrumb based on the path.


  return getDefaultBreadcrumb({
    pathSection: pathSection,
    // include a "Home" breadcrumb by default (can be overrode or disabled in config).
    currentSection: pathSection === '/' ? 'Home' : currentSection,
    location: location
  });
};
/**
 * Splits the pathname into sections, then search for matches in the routes
 * a user-provided breadcrumb OR a sensible default.
*/


var getBreadcrumbs = function getBreadcrumbs(_ref5) {
  var routes = _ref5.routes,
      location = _ref5.location,
      _ref5$options = _ref5.options,
      options = _ref5$options === void 0 ? {} : _ref5$options;
  var matches = [];
  var pathname = location.pathname;
  pathname.split('?')[0] // Remove trailing slash "/" from pathname.
  .replace(/\/$/, '') // Split pathname into sections.
  .split('/') // Reduce over the sections and call `getBreadcrumbMatch()` for each section.
  .reduce(function (previousSection, currentSection) {
    // Combine the last route section with the currentSection.
    // For example, `pathname = /1/2/3` results in match checks for
    // `/1`, `/1/2`, `/1/2/3`.
    var pathSection = !currentSection ? '/' : "".concat(previousSection, "/").concat(currentSection);
    var breadcrumb = getBreadcrumbMatch(_objectSpread2({
      currentSection: currentSection,
      location: location,
      pathSection: pathSection,
      routes: routes
    }, options)); // Add the breadcrumb to the matches array
    // unless the user has explicitly passed.
    // { path: x, breadcrumb: null } to disable.

    if (breadcrumb !== NO_BREADCRUMB) {
      matches.push(breadcrumb);
    }

    return pathSection === '/' ? '' : pathSection;
  }, '');
  return matches;
};
/**
 * Takes a route array and recursively flattens it IF there are
 * nested routes in the config.
*/

var flattenRoutes = function flattenRoutes(routes) {
  return routes.reduce(function (arr, route) {
    if (route.routes) {
      return arr.concat([route].concat(_toConsumableArray(flattenRoutes(route.routes))));
    }

    return arr.concat(route);
  }, []);
};

var index = (function (routes, options) {
  return function (Component) {
    return withRouter(function (props) {
      return createElement(Component, _objectSpread2({}, props, {
        // @ts-ignore-next-line
        breadcrumbs: getBreadcrumbs({
          routes: flattenRoutes(routes || []),
          location: props.location,
          options: options
        })
      }));
    });
  };
});

export default index;
export { getBreadcrumbs };
//# sourceMappingURL=index.js.map
